using Alpaca.Markets;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using QuantResearchAgent.Core;
using System.Collections.Concurrent;

namespace QuantResearchAgent.Services;

public class AlpacaService
{
    private readonly ILogger<AlpacaService> _logger;
    private readonly IConfiguration _configuration;
    private readonly IAlpacaTradingClient? _tradingClient;
    private readonly IAlpacaDataClient? _dataClient;
    private readonly LeanDataService _leanDataService;
    private readonly ConcurrentDictionary<string, List<IBar>> _historicalDataCache = new();

    public AlpacaService(ILogger<AlpacaService> logger, IConfiguration configuration, LeanDataService leanDataService)
    {
        _logger = logger;
        _configuration = configuration;
        _leanDataService = leanDataService;

        var apiKey = configuration["Alpaca:ApiKey"];
        var secretKey = configuration["Alpaca:SecretKey"];
        var isPaperTrading = configuration.GetValue<bool>("Alpaca:IsPaperTrading", true);

        _logger.LogInformation("Initializing Alpaca service with API Key: {ApiKey}, IsPaper: {IsPaper}", 
            string.IsNullOrEmpty(apiKey) ? "NOT_SET" : $"{apiKey[..8]}...", isPaperTrading);

        if (string.IsNullOrEmpty(apiKey) || string.IsNullOrEmpty(secretKey) || 
            apiKey == "YOUR_ALPACA_API_KEY" || secretKey == "YOUR_ALPACA_SECRET_KEY")
        {
            _logger.LogWarning("Alpaca API keys not configured. Using demo mode.");
            return;
        }

        try
        {
            var environment = isPaperTrading ? Environments.Paper : Environments.Live;

            _tradingClient = environment.GetAlpacaTradingClient(new SecretKey(apiKey, secretKey));
            _dataClient = environment.GetAlpacaDataClient(new SecretKey(apiKey, secretKey));

            _logger.LogInformation("Alpaca service initialized successfully in {Environment} mode", isPaperTrading ? "Paper" : "Live");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize Alpaca clients");
        }
    }

    public async Task<MarketData?> GetMarketDataAsync(string symbol)
    {
        try
        {
            if (_dataClient == null)
            {
                _logger.LogWarning("Alpaca client not initialized. Cannot fetch market data for {Symbol}", symbol);
                return null;
            }

            // Get latest quote for real-time price
            var quote = await _dataClient.GetLatestQuoteAsync(new LatestMarketDataRequest(symbol));

            // Get latest trade for volume and price confirmation  
            var trade = await _dataClient.GetLatestTradeAsync(new LatestMarketDataRequest(symbol));

            // Get recent bars for daily high/low
            var barsRequest = new HistoricalBarsRequest(
                symbol,
                DateTime.UtcNow.AddDays(-2),
                DateTime.UtcNow,
                BarTimeFrame.Day);

            var barsResponse = await _dataClient.GetHistoricalBarsAsync(barsRequest);
            var bars = barsResponse.Items.ContainsKey(symbol) ? barsResponse.Items[symbol].ToList() : new List<IBar>();

            var latestBar = bars.LastOrDefault();
            var previousBar = bars.Count > 1 ? bars[bars.Count - 2] : null;

            var currentPrice = trade?.Price ?? quote?.BidPrice ?? 0;
            var previousClose = previousBar?.Close ?? currentPrice;
            var change24h = currentPrice - previousClose;

            var marketData = new MarketData
            {
                Symbol = symbol,
                Price = (double)currentPrice,
                Volume = (long)(latestBar?.Volume ?? trade?.Size ?? 0),
                High24h = (double)(latestBar?.High ?? currentPrice),
                Low24h = (double)(latestBar?.Low ?? currentPrice),
                Change24h = (double)change24h,
                Timestamp = trade?.TimestampUtc ?? quote?.TimestampUtc ?? DateTime.UtcNow
            };

            _logger.LogInformation("Fetched market data for {Symbol}: Price={Price:C}, Volume={Volume}", 
                symbol, currentPrice, marketData.Volume);

            return marketData;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching market data for {Symbol}", symbol);
            return null;
        }
    }

    public async Task<List<IBar>> GetHistoricalBarsAsync(string symbol, int days = 30, BarTimeFrame? timeFrame = null)
    {
        try
        {
            // First try to get data from Alpaca API if client is initialized
            if (_dataClient != null)
            {
                _logger.LogInformation("Attempting to fetch data from Alpaca API for {Symbol}", symbol);
                var alpacaBars = await GetAlpacaHistoricalBarsAsync(symbol, days, timeFrame);
                
                if (alpacaBars.Any())
                {
                    _logger.LogInformation("Successfully fetched {Count} bars from Alpaca API for {Symbol}", alpacaBars.Count, symbol);
                    return alpacaBars;
                }
                
                _logger.LogWarning("No data returned from Alpaca API for {Symbol}, trying Lean data fallback", symbol);
            }
            else
            {
                _logger.LogInformation("Alpaca client not initialized, using Lean data for {Symbol}", symbol);
            }

            // Fallback to Lean data
            return await GetLeanHistoricalBarsAsync(symbol, days);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GetHistoricalBarsAsync for {Symbol}, trying Lean fallback", symbol);
            return await GetLeanHistoricalBarsAsync(symbol, days);
        }
    }

    private async Task<List<IBar>> GetAlpacaHistoricalBarsAsync(string symbol, int days = 30, BarTimeFrame? timeFrame = null)
    {
        try
        {
            var cacheKey = $"{symbol}_{days}_{timeFrame?.ToString() ?? "1D"}";
            
            if (_historicalDataCache.TryGetValue(cacheKey, out var cached))
            {
                // Return cached data if it's less than 5 minutes old
                var lastBar = cached.LastOrDefault();
                if (lastBar != null && DateTime.UtcNow - lastBar.TimeUtc < TimeSpan.FromMinutes(5))
                {
                    _logger.LogInformation("Returning cached Alpaca data for {Symbol}, {Count} bars", symbol, cached.Count);
                    return cached;
                }
            }

            // Extend the date range to account for weekends and holidays
            var endDate = DateTime.UtcNow;
            var startDate = endDate.AddDays(-(days + 10)); // Add extra days to ensure we get enough data
            
            _logger.LogInformation("Fetching historical data for {Symbol} from {StartDate} to {EndDate}", 
                symbol, startDate, endDate);

            var request = new HistoricalBarsRequest(
                symbol,
                startDate,
                endDate,
                timeFrame ?? BarTimeFrame.Day);

            _logger.LogDebug("Making Alpaca API request for {Symbol} with timeframe {TimeFrame}", symbol, timeFrame ?? BarTimeFrame.Day);

            var response = await _dataClient!.GetHistoricalBarsAsync(request);
            
            _logger.LogDebug("Alpaca API response received. Found data for {SymbolCount} symbols: {Symbols}", 
                response.Items.Count, string.Join(", ", response.Items.Keys));
            
            if (!response.Items.ContainsKey(symbol))
            {
                _logger.LogWarning("No historical data found in response for symbol {Symbol}. Available symbols: {AvailableSymbols}", 
                    symbol, string.Join(", ", response.Items.Keys));
                return new List<IBar>();
            }
            
            var allBars = response.Items[symbol].ToList();
            
            // Take only the requested number of most recent bars
            var bars = allBars.OrderByDescending(b => b.TimeUtc).Take(days).OrderBy(b => b.TimeUtc).ToList();

            _historicalDataCache[cacheKey] = bars;
            _logger.LogInformation("Fetched {TotalBars} total bars, returning {RequestedBars} most recent bars for {Symbol}", 
                allBars.Count, bars.Count, symbol);

            if (bars.Count == 0)
            {
                _logger.LogWarning("Historical data request returned 0 bars for {Symbol}. Market might be closed or symbol invalid.", symbol);
                
                // Log detailed response info for debugging
                _logger.LogDebug("Response contained {SymbolCount} symbols: {Symbols}", 
                    response.Items.Count, string.Join(", ", response.Items.Keys));
            }

            return bars;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching historical bars from Alpaca for {Symbol}: {Message}", symbol, ex.Message);
            return new List<IBar>();
        }
    }

    private async Task<List<IBar>> GetLeanHistoricalBarsAsync(string symbol, int days = 30)
    {
        try
        {
            _logger.LogInformation("Fetching data from Lean data files for {Symbol}", symbol);
            
            // Check if we have data for this symbol in Lean format
            var hasEquityData = await _leanDataService.HasDataForSymbolAsync(symbol, false);
            var hasCryptoData = await _leanDataService.HasDataForSymbolAsync(symbol, true);
            
            List<LeanBar> leanBars;
            
            if (hasEquityData)
            {
                _logger.LogInformation("Found equity data for {Symbol} in Lean format", symbol);
                leanBars = await _leanDataService.GetEquityBarsAsync(symbol, "daily", days);
            }
            else if (hasCryptoData)
            {
                _logger.LogInformation("Found crypto data for {Symbol} in Lean format", symbol);
                leanBars = await _leanDataService.GetCryptoBarsAsync(symbol, "daily", days);
            }
            else
            {
                _logger.LogWarning("No Lean data found for {Symbol}. Attempting to download...", symbol);
                
                // Try to download data using the Python pipeline
                var downloadSuccess = await _leanDataService.TriggerDataDownloadAsync(symbol, false, days);
                if (downloadSuccess)
                {
                    _logger.LogInformation("Successfully downloaded data for {Symbol}, retrying...", symbol);
                    leanBars = await _leanDataService.GetEquityBarsAsync(symbol, "daily", days);
                }
                else
                {
                    _logger.LogError("Failed to download data for {Symbol}", symbol);
                    return new List<IBar>();
                }
            }

            // Convert LeanBar to IBar
            var bars = leanBars.Select(lb => new AlpacaBar
            {
                TimeUtc = lb.Time,
                Open = lb.Open,
                High = lb.High,
                Low = lb.Low,
                Close = lb.Close,
                Volume = (ulong)lb.Volume
            }).Cast<IBar>().ToList();

            _logger.LogInformation("Converted {Count} Lean bars to Alpaca format for {Symbol}", bars.Count, symbol);
            return bars;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching data from Lean files for {Symbol}", symbol);
            return new List<IBar>();
        }
    }
}

// Simple implementation of IBar for Lean data
public class AlpacaBar : IBar
{
    public string Symbol { get; set; } = string.Empty;
    public DateTime TimeUtc { get; set; }
    public decimal Open { get; set; }
    public decimal High { get; set; }
    public decimal Low { get; set; }
    public decimal Close { get; set; }
    public decimal Volume { get; set; }
    public decimal? Vwap { get; set; }
    public ulong? TradeCount { get; set; }
}

    public async Task<List<MarketData>> GetMultipleSymbolDataAsync(params string[] symbols)
    {
        var tasks = symbols.Select(GetMarketDataAsync);
        var results = await Task.WhenAll(tasks);
        
        return results.Where(r => r != null).ToList()!;
    }

    public async Task<IAccount?> GetAccountInfoAsync()
    {
        try
        {
            if (_tradingClient == null)
            {
                _logger.LogWarning("Alpaca trading client not initialized");
                return null;
            }

            return await _tradingClient.GetAccountAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching account information");
            return null;
        }
    }

    public async Task<List<IPosition>> GetPositionsAsync()
    {
        try
        {
            if (_tradingClient == null)
            {
                _logger.LogWarning("Alpaca trading client not initialized");
                return new List<IPosition>();
            }

            var positions = await _tradingClient.ListPositionsAsync();
            return positions.ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching positions");
            return new List<IPosition>();
        }
    }

    public async Task<IOrder?> PlaceOrderAsync(string symbol, OrderQuantity quantity, OrderSide side, OrderType orderType, TimeInForce timeInForce)
    {
        try
        {
            if (_tradingClient == null)
            {
                _logger.LogWarning("Alpaca trading client not initialized");
                return null;
            }

            var request = new NewOrderRequest(symbol, quantity, side, orderType, timeInForce);
            var order = await _tradingClient.PostOrderAsync(request);
            
            _logger.LogInformation("Order placed: {Symbol} {Side} {Quantity} at {Type}", symbol, side, quantity, orderType);
            return order;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error placing order for {Symbol}", symbol);
            return null;
        }
    }
}
